name: Build Prebuilt Binaries

on:
  # Trigger when a new release is created in the upstream protobuf repository
  repository_dispatch:
    types: [upstream-release]
  workflow_dispatch:
    inputs:
      upstream_tag:
        description: 'Upstream release tag (e.g., v34.0)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        include:
          # MSVC with static runtime (MT)
          - variant: msvc-mt
            cmake_flags: -DCMAKE_BUILD_TYPE=Release -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_EXAMPLES=OFF -Dprotobuf_WITH_ZLIB=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_FLAGS_RELEASE="/MT" -DCMAKE_C_FLAGS_RELEASE="/MT"
            artifact_name: protobuf-win64-msvc-mt.zip
            setup_msvc: true
          # MSVC with dynamic runtime (MD)
          - variant: msvc-md
            cmake_flags: -DCMAKE_BUILD_TYPE=Release -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_EXAMPLES=OFF -Dprotobuf_WITH_ZLIB=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_FLAGS_RELEASE="/MD" -DCMAKE_C_FLAGS_RELEASE="/MD"
            artifact_name: protobuf-win64-msvc-md.zip
            setup_msvc: true
          # MSVC with static runtime debug (MTd)
          - variant: msvc-mtd
            cmake_flags: -DCMAKE_BUILD_TYPE=Debug -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_EXAMPLES=OFF -Dprotobuf_WITH_ZLIB=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_FLAGS_DEBUG="/MTd" -DCMAKE_C_FLAGS_DEBUG="/MTd"
            artifact_name: protobuf-win64-msvc-mtd.zip
            setup_msvc: true
          # MSVC with dynamic runtime debug (MDd)
          - variant: msvc-mdd
            cmake_flags: -DCMAKE_BUILD_TYPE=Debug -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_EXAMPLES=OFF -Dprotobuf_WITH_ZLIB=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_CXX_FLAGS_DEBUG="/MDd" -DCMAKE_C_FLAGS_DEBUG="/MDd"
            artifact_name: protobuf-win64-msvc-mdd.zip
            setup_msvc: true
          # MinGW
          - variant: mingw
            cmake_flags: -DCMAKE_BUILD_TYPE=Release -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_EXAMPLES=OFF -Dprotobuf_WITH_ZLIB=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_C_FLAGS="-static-libgcc -static-libstdc++" -DCMAKE_CXX_FLAGS="-static-libgcc -static-libstdc++"
            artifact_name: protobuf-win64-mingw.zip
            setup_msvc: false
          # Android ARM64
          - variant: android-arm64
            cmake_flags: -DCMAKE_BUILD_TYPE=Release -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_EXAMPLES=OFF -Dprotobuf_WITH_ZLIB=OFF -DCMAKE_CXX_STANDARD=17 -Dprotobuf_BUILD_PROTOC_BINARIES=OFF
            artifact_name: protobuf-android-arm64.zip
            setup_android: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get upstream tag
        id: get_tag
        run: |
          if ('${{ github.event_name }}' -eq 'workflow_dispatch') {
            "tag=${{ inputs.upstream_tag }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8
          } elseif ('${{ github.event_name }}' -eq 'repository_dispatch') {
            "tag=${{ github.event.client_payload.tag }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8
          }
        shell: pwsh

      - name: Fetch upstream tag
        run: |
          git remote add upstream https://github.com/protocolbuffers/protobuf.git
          git fetch upstream --tags
          git checkout ${{ steps.get_tag.outputs.tag }}

      - name: Setup MSVC
        if: matrix.setup_msvc
        uses: ilammy/msvc-dev-cmd@v1.12.1

      - name: Setup Ninja
        run: |
          choco install ninja
          echo "C:\Program Files\Ninja" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Setup MinGW
        if: matrix.variant == 'mingw'
        run: |
          choco install mingw -y
          echo "C:\ProgramData\chocolatey\lib\mingw\tools\install\mingw64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Setup Android NDK
        if: matrix.setup_android
        run: |
          $ndkVersion = "r26c"
          $ndkUrl = "https://dl.google.com/android/repository/android-ndk-r26c-windows.zip"
          Invoke-WebRequest -Uri $ndkUrl -OutFile ndk.zip
          Expand-Archive -Path ndk.zip -DestinationPath .
          echo "ANDROID_NDK=$env:GITHUB_WORKSPACE\android-ndk-r26c" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "$env:GITHUB_WORKSPACE\android-ndk-r26c" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Configure CMake (MSVC)
        if: matrix.setup_msvc
        run: |
          cmake -B build -S . -G Ninja ${{ matrix.cmake_flags }} -DCMAKE_INSTALL_PREFIX=install

      - name: Configure CMake (MinGW)
        if: matrix.variant == 'mingw'
        run: |
          cmake -B build -S . -G Ninja ${{ matrix.cmake_flags }} -DCMAKE_INSTALL_PREFIX=install -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_MAKE_PROGRAM=ninja

      - name: Configure CMake (Android ARM64)
        if: matrix.variant == 'android-arm64'
        run: |
          cmake -B build -S . -G Ninja ${{ matrix.cmake_flags }} -DCMAKE_INSTALL_PREFIX=install -DCMAKE_TOOLCHAIN_FILE="$env:ANDROID_NDK\build\cmake\android.toolchain.cmake" -DANDROID_ABI=arm64-v8a -DANDROID_PLATFORM=android-24 -DANDROID_STL=c++_shared

      - name: Build
        run: |
          $config = if ('${{ matrix.variant }}' -match 'mtd|mdd') { 'Debug' } else { 'Release' }
          cmake --build build --config $config --parallel

      - name: Install
        run: |
          $config = if ('${{ matrix.variant }}' -match 'mtd|mdd') { 'Debug' } else { 'Release' }
          cmake --install build --config $config --prefix install

      - name: Generate build manifest
        run: |
          # Determine configuration
          $config = if ('${{ matrix.variant }}' -match 'mtd|mdd') { 'Debug' } else { 'Release' }
          $variant = "${{ matrix.variant }}"
          
          # Determine architecture (FIX #1: Android should be arm64-v8a, not x64)
          $arch = switch ($variant) {
            "android-arm64" { "arm64-v8a" }
            default { "x64" }
          }
          
          # Get git commit (FIX #2: trim whitespace)
          $gitCommit = (git rev-parse HEAD).Trim()
          
          # Get timestamp in UTC ISO format
          $timestampUtc = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
          
          # Get runner info (FIX #3: use correct fields, add runnerName)
          $runnerInfo = @{
            os = $env:RUNNER_OS
            runnerName = $env:RUNNER_NAME
          }
          if ($env:ImageVersion) {
            $runnerInfo.imageVersion = $env:ImageVersion
          }
          
          # Initialize toolchain object
          $toolchain = @{}
          
          # Get CMake version (FIX #4: trim)
          $cmakeVersion = (cmake --version 2>&1 | Select-Object -First 1).Trim()
          $toolchain['cmake'] = $cmakeVersion
          
          # Get Ninja version if available (FIX #5: trim)
          try {
            $ninjaVersion = (ninja --version 2>&1).Trim()
            if ($LASTEXITCODE -eq 0) {
              $toolchain['ninja'] = $ninjaVersion
            }
          } catch {}
          
          # Read CMakeCache.txt for compiler/generator info (FIX #6: evidence from actual build)
          $cachePath = "build\CMakeCache.txt"
          if (Test-Path $cachePath) {
            $cacheContent = Get-Content $cachePath
            function Get-CMakeCache {
              param($key)
              $line = $cacheContent | Where-Object { $_ -match "^$key:.*=" } | Select-Object -First 1
              if ($line) {
                return ($line -replace "^[^=]+=", "").Trim()
              }
              return $null
            }
            $generator = Get-CMakeCache "CMAKE_GENERATOR"
            if ($generator) { $toolchain['cmake_generator'] = $generator }
            $cxxCompiler = Get-CMakeCache "CMAKE_CXX_COMPILER"
            if ($cxxCompiler) { $toolchain['cxx_compiler'] = $cxxCompiler }
            $cCompiler = Get-CMakeCache "CMAKE_C_COMPILER"
            if ($cCompiler) { $toolchain['c_compiler'] = $cCompiler }
            $cxxCompilerVersion = Get-CMakeCache "CMAKE_CXX_COMPILER_VERSION"
            if ($cxxCompilerVersion) { $toolchain['cxx_compiler_version'] = $cxxCompilerVersion }
          }
          
          # MSVC specific
          if ('${{ matrix.setup_msvc }}' -eq 'true') {
            # Get MSVC CL version (FIX #7: correct regex, no prefix duplication)
            $clVersion = $null
            try {
              $clOut = cl 2>&1 | Out-String
              $m = [regex]::Match($clOut, "Compiler Version ([0-9]+\.[0-9]+\.[0-9]+)")
              if ($m.Success) {
                $clVersion = $m.Groups[1].Value
              }
            } catch {}
            
            # Hard validation for MSVC variants (FIX #8: fail if cl version not detected)
            if ([string]::IsNullOrEmpty($clVersion)) {
              throw "Failed to detect MSVC cl version. Ensure msvc-dev-cmd ran and cl is on PATH."
            }
            $toolchain['msvc_cl_version'] = $clVersion
            
            # Get Visual Studio installation info using vswhere (FIX #9: handle array correctly, use -products *)
            try {
              $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
              if (Test-Path $vswhere) {
                $vsInfo = (& $vswhere -latest -products * -format json | ConvertFrom-Json | Select-Object -First 1)
                if ($vsInfo) {
                  $toolchain['vs_installationVersion'] = $vsInfo.installationVersion
                  $toolchain['vs_productId'] = $vsInfo.productId
                }
              }
            } catch {}
            
            # Add VC tools install directory (FIX #10: helps identify toolset version)
            if ($env:VCToolsInstallDir) {
              $toolchain['vc_tools_install_dir'] = $env:VCToolsInstallDir
            }
            
            # Get Windows SDK version
            $windowsSdk = $env:WindowsSDKVersion
            if ($windowsSdk) {
              $windowsSdk = $windowsSdk.TrimEnd('\')
            }
            $toolchain['windows_sdk'] = $windowsSdk
          }
          
          # MinGW specific
          if ($variant -eq 'mingw') {
            try {
              $gccVersion = (gcc --version 2>&1 | Select-Object -First 1).Trim()
              if ($LASTEXITCODE -eq 0) {
                $toolchain['mingw_gcc_version'] = $gccVersion
              }
            } catch {}
          }
          
          # Android specific (FIX #11: hardcode version, add path)
          if ('${{ matrix.setup_android }}' -eq 'true') {
            $toolchain['android_ndk_version'] = "r26c"
            if ($env:ANDROID_NDK) {
              $toolchain['android_ndk_path'] = $env:ANDROID_NDK
            }
            
            # Get clang version from NDK
            try {
              $clangPath = Join-Path $env:ANDROID_NDK "toolchains\llvm\prebuilt\windows-x86_64\bin\clang.exe"
              if (Test-Path $clangPath) {
                $clangVersion = (& $clangPath --version 2>&1 | Select-Object -First 1).Trim()
                if ($LASTEXITCODE -eq 0) {
                  $toolchain['clang_version'] = $clangVersion
                }
              }
            } catch {}
          }
          
          # Determine MSVC runtime
          $msvcRuntime = $null
          if ('${{ matrix.setup_msvc }}' -eq 'true') {
            switch ($variant) {
              'msvc-mt' { $msvcRuntime = 'MT' }
              'msvc-md' { $msvcRuntime = 'MD' }
              'msvc-mtd' { $msvcRuntime = 'MTd' }
              'msvc-mdd' { $msvcRuntime = 'MDd' }
            }
          }
          
          # Build manifest object
          $manifest = @{
            library = @{
              name = "protobuf"
              upstream_tag = "${{ steps.get_tag.outputs.tag }}"
              git_commit = $gitCommit
            }
            build = @{
              variant = $variant
              configuration = $config
              arch = $arch
              timestamp_utc = $timestampUtc
              runner = $runnerInfo
            }
            toolchain = $toolchain
            abi = @{}
          }
          
          # Add ABI info for MSVC
          if ($msvcRuntime) {
            $manifest['abi']['msvc_runtime'] = $msvcRuntime
          }
          
          # Add C++ standard (extracted from cmake_flags)
          if ('${{ matrix.cmake_flags }}' -match '-DCMAKE_CXX_STANDARD=(\d+)') {
            $manifest['abi']['cxx_standard'] = $matches[1]
          } else {
            $manifest['abi']['cxx_standard'] = "17"
          }
          
          # Write manifest to JSON file
          $manifestJson = $manifest | ConvertTo-Json -Depth 10
          New-Item -ItemType Directory -Path "install" -Force | Out-Null
          $manifestJson | Out-File -FilePath "install\build-manifest.json" -Encoding utf8
          
          Write-Host "Generated build-manifest.json:"
          Write-Host $manifestJson
        shell: pwsh

      - name: Create package
        run: |
          $version = "${{ steps.get_tag.outputs.tag }}" -replace '^v', ''
          Compress-Archive -Path install\* -DestinationPath ${{ matrix.artifact_name }} -Force
          Write-Host "Created package: ${{ matrix.artifact_name }}"

      - name: Upload build manifest
        uses: actions/upload-artifact@v4
        with:
          name: build-manifest-${{ matrix.variant }}
          path: install/build-manifest.json
          retention-days: 7
          if-no-files-found: error

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.artifact_name }}
          retention-days: 7

  create-release:
    needs: build-and-release
    runs-on: windows-2022
    steps:
      - name: Get upstream tag
        id: get_tag
        run: |
          if ('${{ github.event_name }}' -eq 'workflow_dispatch') {
            "tag=${{ inputs.upstream_tag }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8
          } elseif ('${{ github.event_name }}' -eq 'repository_dispatch') {
            "tag=${{ github.event.client_payload.tag }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8
          }
        shell: pwsh

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create combined package
        run: |
          $version = "${{ steps.get_tag.outputs.tag }}" -replace '^v', ''
          $combinedDir = "combined"
          New-Item -ItemType Directory -Path $combinedDir -Force
          
          foreach ($variantDir in Get-ChildItem -Path artifacts -Directory) {
            $variantName = $variantDir.Name
            $subdirName = ""
            
            switch ($variantName) {
              "protobuf-win64-msvc-mt.zip" { $subdirName = "msvc-mt" }
              "protobuf-win64-msvc-md.zip" { $subdirName = "msvc-md" }
              "protobuf-win64-msvc-mtd.zip" { $subdirName = "msvc-mtd" }
              "protobuf-win64-msvc-mdd.zip" { $subdirName = "msvc-mdd" }
              "protobuf-win64-mingw.zip" { $subdirName = "mingw" }
              "protobuf-android-arm64.zip" { $subdirName = "android-arm64" }
              default { $subdirName = $variantName -replace '\.zip$', '' }
            }
            
            # Get the actual zip file inside the variant directory
            $zipFile = Get-ChildItem -Path $variantDir.FullName -Filter "*.zip" | Select-Object -First 1
            if ($zipFile) {
              $targetDir = Join-Path $combinedDir $subdirName
              Expand-Archive -Path $zipFile.FullName -DestinationPath $targetDir -Force
              Write-Host "Extracted $variantName to $targetDir"
            }
          }
          
          $combinedPackage = "protobuf-${version}-all-variants.zip"
          Compress-Archive -Path $combinedDir\* -DestinationPath $combinedPackage -Force
          Write-Host "Created combined package: $combinedPackage"
        shell: pwsh

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_tag.outputs.tag }}
          name: Protobuf ${{ steps.get_tag.outputs.tag }} Prebuilt Binaries
          body: |
            Prebuilt protobuf binaries for ${{ steps.get_tag.outputs.tag }}

            This release includes multiple build variants:

            **Windows x64:**
            - **MSVC-MT**: Built with Microsoft Visual C++ using static runtime library (/MT) - Release
            - **MSVC-MD**: Built with Microsoft Visual C++ using dynamic runtime library (/MD) - Release
            - **MSVC-MTd**: Built with Microsoft Visual C++ using static runtime library (/MTd) - Debug
            - **MSVC-MDd**: Built with Microsoft Visual C++ using dynamic runtime library (/MDd) - Debug
            - **MinGW**: Built with MinGW-w64 GCC compiler

            **Android:**
            - **ARM64**: Built with Android NDK r26c for arm64-v8a architecture

            **Combined Package:**
            - **All Variants**: Contains all build variants in a single zip package, each in its own subdirectory (msvc-mt/, msvc-md/, msvc-mtd/, msvc-mdd/, mingw/, android-arm64/)

            Built from upstream tag: ${{ steps.get_tag.outputs.tag }}
          files: |
            artifacts/*/*.zip
            *.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}